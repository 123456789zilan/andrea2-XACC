

 layout\+: post title\+: Builders permalink\+: /design/builders \subsection*{category\+: design }

Objects in Fire should be constructed using developer-\/provided specializations of the build$<$T$>$() template function, which is described in \hyperlink{a00398_source}{build.\+h}.

Object construction can be problematic in software projects if the method of initializing those objects changes. For example, it may be sufficient to initialize an object with the following\+:


\begin{DoxyCode}
MyCustomClass object; \textcolor{comment}{// Nullary constructor}
MyCustomClass copiedObject(\textcolor{keywordtype}{object}); \textcolor{comment}{// Copy constructor}
MyCustomClass otherObject(5); \textcolor{comment}{// Special constructor that does something else.}
\end{DoxyCode}


What happens if the design of {\itshape My\+Custom\+Class} changes so that a special {\itshape initialize} operation must be called after the constructor? Or what if data members need to be filled? Then initialization would look like this\+:


\begin{DoxyCode}
MyCustomClass object(5); \textcolor{comment}{// Pass a special argument}
\textcolor{keywordtype}{object}.setX(x); \textcolor{comment}{// Set some data}
\textcolor{keywordtype}{object}.setY(y);
\textcolor{keywordtype}{object}.init(); \textcolor{comment}{// Initialize the object for some long-running work after construction}
\end{DoxyCode}


This quickly becomes troublesome if {\itshape My\+Custom\+Class} is used in many places because it requires a lot of code and could lead to bugs. Thus, Fire uses a templated \char`\"{}builder\char`\"{} function to construct objects like so


\begin{DoxyCode}
\textcolor{keyword}{auto} \textcolor{keywordtype}{object} = build<MyCustomClass>(); \textcolor{comment}{// Default construction}
\textcolor{keyword}{auto} otherObject = build<MyCustomClass>(5,x,y); \textcolor{comment}{// Initialized with data}
\end{DoxyCode}


where the build$<$T$>$() template is specialized by the developer specifically for constructing My\+Custom\+Class in appropriate ways. This eliminates the details of exactly how My\+Custom\+Class is constructed and additionally avoids the \char`\"{}pollution\char`\"{} of duplicating the code to construct My\+Custom\+Class every it is used. Different versions of build$<$T$>$() exist, including versions for instantiation by lists and other input arguments; both versions in the code sample above are valid.

The cleanest way to provide specializations of build$<$T$>$() for any class is after the class in the header file where the class is defined.

The build$<$T$>$() template function is currently defined in \hyperlink{a00398_source}{build.\+h} in the parsers module, but may move in the future.

\subsection*{Example}

The \hyperlink{a00320_source}{Reaction.\+h} file in the astrophysics module has a good examples of providing a specialization of build$<$T$>$(). The only catch is that build$<$T$>$() specializations must be created in the {\itshape fire} namespace, not a subspace.

\hyperlink{a00332_source}{Species\+Local\+Parser.\+h} shows a good example of \char`\"{}implicit instantiation\char`\"{} for the build$<$T$>$() function for the Species class. In this case, the compiler automatically creates the specialized version of build$<$T$>$() based on type inference and the second version of build$<$T$>$() in \hyperlink{a00398_source}{build.\+h}.

\subsection*{build$<$T$>$() vs parse$<$T$>$()}

In some cases the build$<$T$>$() can be grammatically cumbersome. Consider the following example\+:


\begin{DoxyCode}
\textcolor{keyword}{auto} parser = build<LocalParser<vector<T>>, \textcolor{keyword}{const} \textcolor{keywordtype}{string} &>(fileName);
parser.parse();
\textcolor{keyword}{auto} myData = speciesParser.getData();
\end{DoxyCode}


The problem with this code is that it is essentially the same thing as what build$<$T$>$() is meant to prevent -\/ bloat that will be copied everywhere! The worst part of the bloat is the template arguments, which are most likely constant across many different parsers. It is better to use parse$<$T$>$() in cases like this, which looks like the following\+:


\begin{DoxyCode}
\textcolor{keyword}{auto} myData = parse<T>(filename);
\end{DoxyCode}


parse$<$T$>$() is specifically designed for returning vectors of type T from local files. It isn\textquotesingle{}t a substitute for complex parsers, but it saves a lot of effort for regular, block-\/structured data.

The two major differences between these two methods are


\begin{DoxyItemize}
\item Code cleanliness
\item parse$<$T$>$() automatically parses the file, whereas build$<$T$>$() probably does and should not.
\end{DoxyItemize}

The second point is really important. Should your build$<$T$>$() parse as well as build? That\textquotesingle{}s a design issue that we\textquotesingle{}ll defer for now, but keep in mind that if your build$<$T$>$() routine parses, then your clients should not use parse$<$T$>$() because it calls build$<$T$>$() too, which means your data will be loaded twice into the same array! This is the reason that default build$<$T$>$() implementations for local parsers in Fire {\bfseries never} call parser.\+parse().

\subsubsection*{Author note}

Note\+: Ideally the default version of build would work for variadic template and function arguments, but at the specific function must be implemented. 