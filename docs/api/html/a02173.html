<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XACC: 2016-10-29-fire-memory-model</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XACC
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">2016-10-29-fire-memory-model </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><hr/>
<p> layout: post title: Memory Model permalink: /design/memory_model </p><h2>category: design </h2>
<p>The memory model in Fire is meant to be simple and efficient. The idea is that sometimes striving for the best performance <em>and</em> the highest architectural purity is stupid and, furthermore, YAGNI.</p>
<p>Fire takes advantage of the latest updates to C++ and relies heavily on C++11 memory management enhancements to get the best performance.</p>
<h1>Return by Value</h1>
<p>There is no need to return by reference (pointer) for most functions in Fire because it uses C++11. Thus the following code is performs very well:</p>
<div class="fragment"><div class="line">vector&lt;int&gt; getVec() {</div><div class="line">    vector&lt;int&gt; myVec;</div><div class="line">    ... <span class="comment">// Some code to fill the vector</span></div><div class="line">    <span class="keywordflow">return</span> myVec;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line">    vector&lt;int&gt; mainVec = getVec();</div><div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p>This code would have performed very slowly in earlier versions of C++ because they did not provide so called "move semantics" like C++11. The problem in older versions of C++ comes from the fact that there would be at least two copies the above code. First, myVec is copied into the return value of getVec() when it returns. Second, the return value of getVec() is copied into mainVec.</p>
<p>C++11 eliminates the second copy with move semantics. The first copy is eliminated by a process called <em>return value optimization,</em> which is implemented directly by the compiler.</p>
<p>The important implication for this is that functions in Fire can be much simpler and easier to understand while simultaneously performing very well, or, as we like to say with purely technical language, "running like a scalded dog." ;-) This performance is especially important for the build&lt;&gt;() template, which encapsulates the construction of objects. Without move semantics and return value optimization, it would perform very poorly unless it returned a pointer.</p>
<h1>Public Data</h1>
<p>The proper implementation of a pure, public data structure in Fire is to use a <em>struct</em> instead of a class. It would would look like:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyData {</div><div class="line">    <span class="keywordtype">int</span> A;</div><div class="line">    <span class="keywordtype">int</span> B;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> C;</div><div class="line"></div><div class="line">    MyData(<span class="keywordtype">int</span> otherC) : C(otherC) {};</div><div class="line">};</div></div><!-- fragment --><h3>Handling Const Members</h3>
<p>As shown in the example, constructors and initializer lists should be used for <em>const</em> data members. This also means that special care should be taken so that structs do not have a large amount of const-qualified members. This makes initialization complicated since const-qualified members must be initialized in the initializer list instead of the body of the constructor. In extreme cases it may be necessary to replace a constructor like</p>
<div class="fragment"><div class="line">MyConstructor(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b, <span class="keywordtype">int</span> c,...) : myA(a), myB(b), myC(c), ... {};</div></div><!-- fragment --><p>with something like</p>
<div class="fragment"><div class="line">MyConstructor(<span class="keyword">const</span> vector&lt;int&gt; &amp; values) : myA(values[0]), myB(values[1]), myC(values[2]), ... {};</div></div><!-- fragment --><p>which has the benefit of having a shorter input argument list. This is convenient for line-fed data parsed from legacy data formats, as is the case for <a class="el" href="a01357.html">fire::astrophysics::Species</a>.</p>
<p>Another possibility is to do something more drastic, like</p>
<div class="fragment"><div class="line">MyConstructor(<span class="keyword">const</span> vector&lt;int&gt; &amp; values) : myValues(values), ... {};</div></div><!-- fragment --><p>where explicitly defining myA, myB, myC and other members has been replaced with an vector. This is not recommended in the case where the vector contains separately accessed values like myA, myB and myC because it is bad design. However, it is ideal in the case where myValues is actually an immutable vector of dense data of a primitive type used for iteration.</p>
<p>If a struct would have so many individual const-qualified data members that a vector would be required to initialize it, then it would be better to switch to a class instead, hold the vector data as private state, and provide access via <em>accessors.</em></p>
<h3>When to use accessors</h3>
<p>Fire uses structs over classes for small data structures of pure data because, in some cases, <em>accessor functions</em> may be evil. Accessors - or functions that start with "get" or "set" - are used as a means of managing access to or hiding the state of "private" data in a class. (Hiding internal state is called <em>encapsulation.</em>) In a class like the following it is clear that the accessors are just fluff since the getA() and setA() functions do no other work than provide access to A, B, and C.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyData {</div><div class="line">    <span class="keywordtype">int</span> A;</div><div class="line">    <span class="keywordtype">int</span> B;</div><div class="line">    <span class="keywordtype">int</span> C;</div><div class="line">    ... <span class="comment">// More properties!</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">int</span> getA() {<span class="keywordflow">return</span> A;};</div><div class="line">    <span class="keywordtype">void</span> setA(<span class="keywordtype">int</span> otherA) {A = otherA;};</div><div class="line">    ... <span class="comment">// More get/set functions for B and C </span></div><div class="line">};</div></div><!-- fragment --><p>If the getA() and setA() functions did some extra work or required other information about internal state, then they would be just fine and well warranted. If they do not do any extra work, then encapsulation is completely violated and can no longer be used as an excuse. That is, the internal state is not actually hidden, so it is better to just make them public. Both C and C++ provide the <em>struct</em> construct for defining a data structure with all public members, and it is a better fit here.</p>
<p>There is another important reason for skipping accessors for pure data structures: Accessors are a common source of bugs! While these types of bugs will be easily caught by a good unit test, they can be avoided all together by not using accessors where that makes sense.</p>
<p>In the last section, one valid case for accessors was discussed: what if a data class with many const-qualified members is needed? Accessors are ideal for providing this information because they keep the code succinct:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyData {</div><div class="line">    <span class="keyword">const</span> vector&lt;int&gt; myConstValues;</div><div class="line">    ... <span class="comment">// More properties!</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">    MyData(<span class="keyword">const</span> vector&lt;int&gt; values) : myConstValues(values) {};</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> getA() {<span class="keywordflow">return</span> vector[8675309];};</div><div class="line">    ... <span class="comment">// More get/set functions for B, C and others  like A.</span></div><div class="line">};</div></div><!-- fragment --><h1>Heap-Allocated Data Arrays</h1>
<p>Fire combines smart pointers and shared pointers for data arrays. Arrays are loaded into shared pointers and passed to functions as raw pointers. The <em>free()</em> and <em>delete()</em> <b>must not be called</b> on raw pointers in Fire routines because the shared pointers are responsible for the lifecycle of the memory to which the pointer points.</p>
<p>Here's an example for creating arrays of data and using them appropriately in Fire:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// Will be added. Sorry!</span></div><div class="line">}</div></div><!-- fragment --><h3>More details</h3>
<p>The best performance for arrays of data in C++ comes from using raw pointers, which comes with the obvious down side of memory leaks. The smart pointer was invented to get around the latter problem, but that safety comes at the cost of performance. In the case of C++ smart pointers, and the standard shared pointer in particular, the cost is atomic increments and decrements every time the smart pointer is passed to a function. In Fire, smart pointers should be used if a client class is going to be responsible for modifying the existence of an object (create it, delete it, reallocate it, etc.) or needs to know when such an event happens. That is, if a client class is going to participate in the <em>memory lifecycle</em> of an object, then it needs to have the shared pointer. If it does not need to participate in the memory lifecycle, then it is only working with the array and only needs some type of reference to it, for which a raw pointer will work just fine. (Actual references are fine too if they work for your problem.)</p>
<p>This is consistent with guidance from the broader C++11 community, (c.f. - <a href="http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/C-11-VC-11-and-Beyond">Herb Sutter's Going Native 2011 talk</a>), but it does run the risk that some unknowing developer will call delete on a pointer. That risk is acceptable because it is minimized when developers RTFM. In practice, accidental deallocations have never happened.</p>
<p>C++ references are not broadly used because Fire makes extensive use of templates and references cannot be stored in templated classes. However, as mentioned above, use them if it works.</p>
<p>This strategy has several benefits that can be summed up simply. Combining the two allows Fire to use an exceptionally small amount of memory, provides very fast access to data on the heap and eliminates memory leaks from its own classes. The latter can be witnessed by testing with memory profilers like Valgrind. (N.B. - We can not do anything about memory leaks in third party dependencies.) </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
